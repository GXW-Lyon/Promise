<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>
  // 加载图片
  // const preloadImage = function(){
  //   return new Promise(function(resolve,reject){
  //     const image = new Image();
  //     image.onload = resolve;
  //     image.onerror = reject;
  //     image.src = path;
  //   })
  // }

  // Generator函数与Promise的结合
  // function getFoo(){
  //   return new Promise(function(resolve,reject){
  //     resolve('foo');
  //   });
  // };
  // const g = function*(){
  //   try{
  //     const foo = yield getFoo();
  //     console.log(foo);
  //   }catch(e){
  //     console.log(e);
  //   }
  // };
  // function run(generator){
  //   const it = generator();
  //   function go(result){
  //     if(result.done) return result.value;
  //     return result.value.then(function(value){
  //       return go(it.next(value));
  //     },function(error){
  //       return go(it.throw(error));
  //     });
  //   };
  //   go(it.next());
  // };
  // run(g);

  // Promise.try()
  // 实际开发中，经常遇到一种情况：不知道或则不想区分，函数是同步还是异步操作，但是享用Promise来处理它。因为这样就可以不管函数是否包含异步操作，都可以用then方法指定下一步流程，用catch方法处理函数抛出的错误。

  // Promise.resolve().then(f);
  // 上面的写法有一个缺点，就是如果函数是同步函数，那么他会在本轮事件的末尾执行。
  // const f = ()=>console.log('now');
  // Promise.resolve().then(f);
  // console.log('next');
  //next
  //now
//上面的代码函数f是同步的，但是用Promise包装了以后，就变成异步执行了。

//改写方式两种。
//1.async函数
// const f = ()=>console.log('now');
// (async()=>f())();
// console.log('next');


// (async function(){
//   f();
// })();
// console.log('next');
// now
// next
// const f = () => console.log('now');
// Promise.try(f);
// console.log('next');

</script>
</body>
</html>